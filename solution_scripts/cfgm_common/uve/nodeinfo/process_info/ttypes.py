#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *


class ConnectionType(object):
  TEST = 0
  IFMAP = 1
  XMPP = 2
  COLLECTOR = 3
  DATABASE = 4
  REDIS_QUERY = 5
  ZOOKEEPER = 6
  DISCOVERY = 7
  APISERVER = 8
  TOR = 9
  REDIS_UVE = 10
  UVEPARTITIONS = 11
  KAFKA_PUB = 12
  OTHER = 13

  _VALUES_TO_NAMES = {
    0: "TEST",
    1: "IFMAP",
    2: "XMPP",
    3: "COLLECTOR",
    4: "DATABASE",
    5: "REDIS_QUERY",
    6: "ZOOKEEPER",
    7: "DISCOVERY",
    8: "APISERVER",
    9: "TOR",
    10: "REDIS_UVE",
    11: "UVEPARTITIONS",
    12: "KAFKA_PUB",
    13: "OTHER",
  }

  _NAMES_TO_VALUES = {
    "TEST": 0,
    "IFMAP": 1,
    "XMPP": 2,
    "COLLECTOR": 3,
    "DATABASE": 4,
    "REDIS_QUERY": 5,
    "ZOOKEEPER": 6,
    "DISCOVERY": 7,
    "APISERVER": 8,
    "TOR": 9,
    "REDIS_UVE": 10,
    "UVEPARTITIONS": 11,
    "KAFKA_PUB": 12,
    "OTHER": 13,
  }

class ConnectionStatus(object):
  INIT = 0
  DOWN = 1
  UP = 2

  _VALUES_TO_NAMES = {
    0: "INIT",
    1: "DOWN",
    2: "UP",
  }

  _NAMES_TO_VALUES = {
    "INIT": 0,
    "DOWN": 1,
    "UP": 2,
  }

class ProcessState(object):
  FUNCTIONAL = 0
  NON_FUNCTIONAL = 1

  _VALUES_TO_NAMES = {
    0: "FUNCTIONAL",
    1: "NON_FUNCTIONAL",
  }

  _NAMES_TO_VALUES = {
    "FUNCTIONAL": 0,
    "NON_FUNCTIONAL": 1,
  }


class ConnectionInfo(object):
  """
  Attributes:
   - type
   - name
   - server_addrs
   - status
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.LIST, 'server_addrs', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'status', None, None, ), # 4
    (5, TType.STRING, 'description', None, None, ), # 5
  )

  def __init__(self, type=None, name=None, server_addrs=None, status=None, description=None,):
    self.type = type
    self.name = name
    self.server_addrs = server_addrs
    self.status = status
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.server_addrs = []
          (length, _etype3, _size0) = iprot.readListBegin()
          read_cnt += length
          for _i4 in xrange(_size0):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem5) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.server_addrs.append(_elem5)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.description) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.type is not None:
      annotations = {}
      if oprot.writeFieldBegin('type', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.name is not None:
      annotations = {}
      if oprot.writeFieldBegin('name', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.server_addrs is not None:
      annotations = {}
      if oprot.writeFieldBegin('server_addrs', TType.LIST, 3, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.server_addrs)) < 0: return -1
      for iter6 in self.server_addrs:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter6) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.status is not None:
      annotations = {}
      if oprot.writeFieldBegin('status', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.description is not None:
      annotations = {}
      if oprot.writeFieldBegin('description', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.description) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.type is not None:
      log_str.write('type = ')
      log_str.write(self.type)
      log_str.write('  ')
    if self.name is not None:
      log_str.write('name = ')
      log_str.write(self.name)
      log_str.write('  ')
    if self.server_addrs is not None:
      log_str.write('server_addrs = ')
      log_str.write('[ ')
      for iter7 in self.server_addrs:
        log_str.write(iter7)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.status is not None:
      log_str.write('status = ')
      log_str.write(self.status)
      log_str.write('  ')
    if self.description is not None:
      log_str.write('description = ')
      log_str.write(self.description)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.type is not None:
      size += getsizeof(self.type)
    if self.name is not None:
      size += getsizeof(self.name)
    if self.server_addrs is not None:
      size += getsizeof(self.server_addrs)
      size += sum(map(getsizeof, self.server_addrs))
    if self.status is not None:
      size += getsizeof(self.status)
    if self.description is not None:
      size += getsizeof(self.description)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProcessStatus(object):
  """
  This data is sent by each of the processes based on it's internal
  state.

  Attributes:
   - module_id
   - instance_id
   - state
   - connection_infos
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'module_id', None, None, ), # 1
    (2, TType.STRING, 'instance_id', None, None, ), # 2
    (3, TType.STRING, 'state', None, None, ), # 3
    (4, TType.LIST, 'connection_infos', (TType.STRUCT,(ConnectionInfo, ConnectionInfo.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'description', None, None, ), # 5
  )

  def __init__(self, module_id=None, instance_id=None, state=None, connection_infos=None, description=None,):
    self.module_id = module_id
    self.instance_id = instance_id
    self.state = state
    self.connection_infos = connection_infos
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.module_id) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.instance_id) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.state) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.connection_infos = []
          (length, _etype11, _size8) = iprot.readListBegin()
          read_cnt += length
          for _i12 in xrange(_size8):
            _elem13 = ConnectionInfo()
            read_cnt += _elem13.read(iprot)
            self.connection_infos.append(_elem13)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.description) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.module_id is not None:
      annotations = {}
      if oprot.writeFieldBegin('module_id', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.module_id) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.instance_id is not None:
      annotations = {}
      if oprot.writeFieldBegin('instance_id', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.instance_id) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.state is not None:
      annotations = {}
      if oprot.writeFieldBegin('state', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.connection_infos is not None:
      annotations = {}
      if oprot.writeFieldBegin('connection_infos', TType.LIST, 4, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.connection_infos)) < 0: return -1
      for iter14 in self.connection_infos:
        if iter14.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.description is not None:
      annotations = {}
      if oprot.writeFieldBegin('description', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.description) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.module_id is not None:
      log_str.write('module_id = ')
      log_str.write(self.module_id)
      log_str.write('  ')
    if self.instance_id is not None:
      log_str.write('instance_id = ')
      log_str.write(self.instance_id)
      log_str.write('  ')
    if self.state is not None:
      log_str.write('state = ')
      log_str.write(self.state)
      log_str.write('  ')
    if self.connection_infos is not None:
      log_str.write('connection_infos = ')
      log_str.write('[ ')
      for iter15 in self.connection_infos:
        log_str.write('<<  ')
        log_str.write(iter15.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.description is not None:
      log_str.write('description = ')
      log_str.write(self.description)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.module_id is not None:
      size += getsizeof(self.module_id)
    if self.instance_id is not None:
      size += getsizeof(self.instance_id)
    if self.state is not None:
      size += getsizeof(self.state)
    if self.connection_infos is not None:
      size += getsizeof(self.connection_infos)
      size += sum(map(getsizeof, self.connection_infos))
    if self.description is not None:
      size += getsizeof(self.description)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DiskPartitionUsageStats(object):
  """
  This data is sent by each of the processes based on it's internal
  state.

  Attributes:
   - partition_type
   - partition_name
   - partition_space_used_1k
   - partition_space_available_1k
   - percentage_partition_space_used
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'partition_type', None, None, ), # 1
    (2, TType.STRING, 'partition_name', None, None, ), # 2
    (3, TType.U64, 'partition_space_used_1k', None, None, ), # 3
    (4, TType.U64, 'partition_space_available_1k', None, None, ), # 4
    (5, TType.U16, 'percentage_partition_space_used', None, None, ), # 5
  )

  def __init__(self, partition_type=None, partition_name=None, partition_space_used_1k=None, partition_space_available_1k=None, percentage_partition_space_used=None,):
    self.partition_type = partition_type
    self.partition_name = partition_name
    self.partition_space_used_1k = partition_space_used_1k
    self.partition_space_available_1k = partition_space_available_1k
    self.percentage_partition_space_used = percentage_partition_space_used

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.partition_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.partition_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.partition_space_used_1k) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.partition_space_available_1k) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U16:
          (length, self.percentage_partition_space_used) = iprot.readU16();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.partition_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('partition_type', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.partition_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.partition_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('partition_name', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.partition_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.partition_space_used_1k is not None:
      annotations = {}
      if oprot.writeFieldBegin('partition_space_used_1k', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.partition_space_used_1k) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.partition_space_available_1k is not None:
      annotations = {}
      if oprot.writeFieldBegin('partition_space_available_1k', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.partition_space_available_1k) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.percentage_partition_space_used is not None:
      annotations = {}
      if oprot.writeFieldBegin('percentage_partition_space_used', TType.U16, 5, annotations) < 0: return -1
      if oprot.writeU16(self.percentage_partition_space_used) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.partition_type is not None:
      log_str.write('partition_type = ')
      log_str.write(self.partition_type)
      log_str.write('  ')
    if self.partition_name is not None:
      log_str.write('partition_name = ')
      log_str.write(self.partition_name)
      log_str.write('  ')
    if self.partition_space_used_1k is not None:
      log_str.write('partition_space_used_1k = ')
      log_str.write(str(self.partition_space_used_1k))
      log_str.write('  ')
    if self.partition_space_available_1k is not None:
      log_str.write('partition_space_available_1k = ')
      log_str.write(str(self.partition_space_available_1k))
      log_str.write('  ')
    if self.percentage_partition_space_used is not None:
      log_str.write('percentage_partition_space_used = ')
      log_str.write(str(self.percentage_partition_space_used))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.partition_type is not None:
      size += getsizeof(self.partition_type)
    if self.partition_name is not None:
      size += getsizeof(self.partition_name)
    if self.partition_space_used_1k is not None:
      size += getsizeof(self.partition_space_used_1k)
    if self.partition_space_available_1k is not None:
      size += getsizeof(self.partition_space_available_1k)
    if self.percentage_partition_space_used is not None:
      size += getsizeof(self.percentage_partition_space_used)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProcessInfo(object):
  """
  This data is sent by each the Node's nodemgr,
  state.

  Attributes:
   - process_name
   - process_state
   - start_count
   - stop_count
   - exit_count
   - last_start_time
   - last_stop_time
   - last_exit_time
   - core_file_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'process_name', None, None, ), # 1
    (2, TType.STRING, 'process_state', None, None, ), # 2
    (3, TType.U32, 'start_count', None, None, ), # 3
    (4, TType.U32, 'stop_count', None, None, ), # 4
    (5, TType.U32, 'exit_count', None, None, ), # 5
    (6, TType.STRING, 'last_start_time', None, None, ), # 6
    (7, TType.STRING, 'last_stop_time', None, None, ), # 7
    (8, TType.STRING, 'last_exit_time', None, None, ), # 8
    (9, TType.LIST, 'core_file_list', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, process_name=None, process_state=None, start_count=None, stop_count=None, exit_count=None, last_start_time=None, last_stop_time=None, last_exit_time=None, core_file_list=None,):
    self.process_name = process_name
    self.process_state = process_state
    self.start_count = start_count
    self.stop_count = stop_count
    self.exit_count = exit_count
    self.last_start_time = last_start_time
    self.last_stop_time = last_stop_time
    self.last_exit_time = last_exit_time
    self.core_file_list = core_file_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.process_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.process_state) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.start_count) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U32:
          (length, self.stop_count) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U32:
          (length, self.exit_count) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.last_start_time) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          (length, self.last_stop_time) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          (length, self.last_exit_time) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.core_file_list = []
          (length, _etype19, _size16) = iprot.readListBegin()
          read_cnt += length
          for _i20 in xrange(_size16):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem21) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.core_file_list.append(_elem21)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.process_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('process_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.process_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.process_state is not None:
      annotations = {}
      if oprot.writeFieldBegin('process_state', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.process_state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.start_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('start_count', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.start_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.stop_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('stop_count', TType.U32, 4, annotations) < 0: return -1
      if oprot.writeU32(self.stop_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.exit_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('exit_count', TType.U32, 5, annotations) < 0: return -1
      if oprot.writeU32(self.exit_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_start_time is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_start_time', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.last_start_time) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_stop_time is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_stop_time', TType.STRING, 7, annotations) < 0: return -1
      if oprot.writeString(self.last_stop_time) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_exit_time is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_exit_time', TType.STRING, 8, annotations) < 0: return -1
      if oprot.writeString(self.last_exit_time) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.core_file_list is not None:
      annotations = {}
      if oprot.writeFieldBegin('core_file_list', TType.LIST, 9, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.core_file_list)) < 0: return -1
      for iter22 in self.core_file_list:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter22) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.process_name is not None:
      log_str.write('process_name = ')
      log_str.write(self.process_name)
      log_str.write('  ')
    if self.process_state is not None:
      log_str.write('process_state = ')
      log_str.write(self.process_state)
      log_str.write('  ')
    if self.start_count is not None:
      log_str.write('start_count = ')
      log_str.write(str(self.start_count))
      log_str.write('  ')
    if self.stop_count is not None:
      log_str.write('stop_count = ')
      log_str.write(str(self.stop_count))
      log_str.write('  ')
    if self.exit_count is not None:
      log_str.write('exit_count = ')
      log_str.write(str(self.exit_count))
      log_str.write('  ')
    if self.last_start_time is not None:
      log_str.write('last_start_time = ')
      log_str.write(self.last_start_time)
      log_str.write('  ')
    if self.last_stop_time is not None:
      log_str.write('last_stop_time = ')
      log_str.write(self.last_stop_time)
      log_str.write('  ')
    if self.last_exit_time is not None:
      log_str.write('last_exit_time = ')
      log_str.write(self.last_exit_time)
      log_str.write('  ')
    if self.core_file_list is not None:
      log_str.write('core_file_list = ')
      log_str.write('[ ')
      for iter23 in self.core_file_list:
        log_str.write(iter23)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.process_name is not None:
      size += getsizeof(self.process_name)
    if self.process_state is not None:
      size += getsizeof(self.process_state)
    if self.start_count is not None:
      size += getsizeof(self.start_count)
    if self.stop_count is not None:
      size += getsizeof(self.stop_count)
    if self.exit_count is not None:
      size += getsizeof(self.exit_count)
    if self.last_start_time is not None:
      size += getsizeof(self.last_start_time)
    if self.last_stop_time is not None:
      size += getsizeof(self.last_stop_time)
    if self.last_exit_time is not None:
      size += getsizeof(self.last_exit_time)
    if self.core_file_list is not None:
      size += getsizeof(self.core_file_list)
      size += sum(map(getsizeof, self.core_file_list))
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
