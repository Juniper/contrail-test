#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException
import cpuinfo.ttypes
import process_info.ttypes


from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class NodeStatus(object):
  """
  This structure used to send NodeStatus data for all node types

  Following are sent by each process individually and aggregation
  will happen on UVE queries.
  - process_status carries process's status [functional/non-functional]
  - process_info carries process's state [up/down]

  Following are sent by nodemgr on behalf of the node
  - disk partition usage
  - core files
  - system memory/cpu usage
  - system cpu info

  Following are sent by nodemgr on behalf of all processes on the node
  - process memory/cpu usage

  Attributes:
   - name
   - deleted
   - status
   - process_status
   - process_info
   - disk_usage_info
   - description
   - all_core_file_list
   - build_info
   - process_mem_cpu_usage
   - system_cpu_info
   - system_mem_usage
   - system_cpu_usage
   - running_package_version
   - installed_package_version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleted', None, None, ), # 2
    (3, TType.STRING, 'status', None, None, ), # 3
    (4, TType.LIST, 'process_status', (TType.STRUCT,(process_info.ttypes.ProcessStatus, process_info.ttypes.ProcessStatus.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'process_info', (TType.STRUCT,(process_info.ttypes.ProcessInfo, process_info.ttypes.ProcessInfo.thrift_spec)), None, ), # 5
    (6, TType.MAP, 'disk_usage_info', (TType.STRING,None,TType.STRUCT,(process_info.ttypes.DiskPartitionUsageStats, process_info.ttypes.DiskPartitionUsageStats.thrift_spec)), None, ), # 6
    (7, TType.STRING, 'description', None, None, ), # 7
    (8, TType.LIST, 'all_core_file_list', (TType.STRING,None), None, ), # 8
    (9, TType.STRING, 'build_info', None, None, ), # 9
    (10, TType.MAP, 'process_mem_cpu_usage', (TType.STRING,None,TType.STRUCT,(cpuinfo.ttypes.ProcessCpuInfo, cpuinfo.ttypes.ProcessCpuInfo.thrift_spec)), None, ), # 10
    None, # 11
    (12, TType.STRUCT, 'system_cpu_info', (cpuinfo.ttypes.SystemCpuInfo, cpuinfo.ttypes.SystemCpuInfo.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'system_mem_usage', (cpuinfo.ttypes.SysMemInfo, cpuinfo.ttypes.SysMemInfo.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'system_cpu_usage', (cpuinfo.ttypes.SysCpuInfo, cpuinfo.ttypes.SysCpuInfo.thrift_spec), None, ), # 14
    (15, TType.STRING, 'running_package_version', None, None, ), # 15
    (16, TType.STRING, 'installed_package_version', None, None, ), # 16
  )

  def __init__(self, name=None, deleted=None, status=None, process_status=None, process_info=None, disk_usage_info=None, description=None, all_core_file_list=None, build_info=None, process_mem_cpu_usage=None, system_cpu_info=None, system_mem_usage=None, system_cpu_usage=None, running_package_version=None, installed_package_version=None,):
    self.name = name
    self.deleted = deleted
    self.status = status
    self.process_status = process_status
    self.process_info = process_info
    self.disk_usage_info = disk_usage_info
    self.description = description
    self.all_core_file_list = all_core_file_list
    self.build_info = build_info
    self.process_mem_cpu_usage = process_mem_cpu_usage
    self.system_cpu_info = system_cpu_info
    self.system_mem_usage = system_mem_usage
    self.system_cpu_usage = system_cpu_usage
    self.running_package_version = running_package_version
    self.installed_package_version = installed_package_version
    self._table = ''

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.deleted) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.process_status = []
          (length, _etype3, _size0) = iprot.readListBegin()
          read_cnt += length
          for _i4 in xrange(_size0):
            _elem5 = process_info.ttypes.ProcessStatus()
            read_cnt += _elem5.read(iprot)
            self.process_status.append(_elem5)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.process_info = []
          (length, _etype9, _size6) = iprot.readListBegin()
          read_cnt += length
          for _i10 in xrange(_size6):
            _elem11 = process_info.ttypes.ProcessInfo()
            read_cnt += _elem11.read(iprot)
            self.process_info.append(_elem11)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.disk_usage_info = {}
          (length, _ktype13, _vtype14, _size12 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i16 in xrange(_size12):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key17) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            _val18 = process_info.ttypes.DiskPartitionUsageStats()
            read_cnt += _val18.read(iprot)
            self.disk_usage_info[_key17] = _val18
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          (length, self.description) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.all_core_file_list = []
          (length, _etype22, _size19) = iprot.readListBegin()
          read_cnt += length
          for _i23 in xrange(_size19):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem24) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.all_core_file_list.append(_elem24)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          (length, self.build_info) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.process_mem_cpu_usage = {}
          (length, _ktype26, _vtype27, _size25 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i29 in xrange(_size25):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key30) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            _val31 = cpuinfo.ttypes.ProcessCpuInfo()
            read_cnt += _val31.read(iprot)
            self.process_mem_cpu_usage[_key30] = _val31
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.system_cpu_info = cpuinfo.ttypes.SystemCpuInfo()
          read_cnt += self.system_cpu_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.system_mem_usage = cpuinfo.ttypes.SysMemInfo()
          read_cnt += self.system_mem_usage.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.system_cpu_usage = cpuinfo.ttypes.SysCpuInfo()
          read_cnt += self.system_cpu_usage.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          (length, self.running_package_version) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          (length, self.installed_package_version) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.name is not None:
      annotations = {}
      if self._table is None or self._table is '': return -1
      annotations['key'] = self._table
      if oprot.writeFieldBegin('name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.deleted is not None:
      annotations = {}
      if oprot.writeFieldBegin('deleted', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.deleted) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.status is not None:
      annotations = {}
      if oprot.writeFieldBegin('status', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.process_status is not None:
      annotations = {}
      annotations['aggtype'] = 'union'
      if oprot.writeFieldBegin('process_status', TType.LIST, 4, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.process_status)) < 0: return -1
      for iter32 in self.process_status:
        if iter32.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.process_info is not None:
      annotations = {}
      annotations['aggtype'] = 'union'
      if oprot.writeFieldBegin('process_info', TType.LIST, 5, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.process_info)) < 0: return -1
      for iter33 in self.process_info:
        if iter33.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disk_usage_info is not None:
      annotations = {}
      annotations['tags'] = ''
      if oprot.writeFieldBegin('disk_usage_info', TType.MAP, 6, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.disk_usage_info)) < 0: return -1
      for kiter34,viter35 in self.disk_usage_info.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter34) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if viter35.write(oprot) < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.description is not None:
      annotations = {}
      if oprot.writeFieldBegin('description', TType.STRING, 7, annotations) < 0: return -1
      if oprot.writeString(self.description) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.all_core_file_list is not None:
      annotations = {}
      if oprot.writeFieldBegin('all_core_file_list', TType.LIST, 8, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.all_core_file_list)) < 0: return -1
      for iter36 in self.all_core_file_list:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter36) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.build_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('build_info', TType.STRING, 9, annotations) < 0: return -1
      if oprot.writeString(self.build_info) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.process_mem_cpu_usage is not None:
      annotations = {}
      annotations['tags'] = '.__key,.cpu_share'
      if oprot.writeFieldBegin('process_mem_cpu_usage', TType.MAP, 10, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.process_mem_cpu_usage)) < 0: return -1
      for kiter37,viter38 in self.process_mem_cpu_usage.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter37) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if viter38.write(oprot) < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.system_cpu_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('system_cpu_info', TType.STRUCT, 12, annotations) < 0: return -1
      if self.system_cpu_info.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.system_mem_usage is not None:
      annotations = {}
      annotations['tags'] = '.node_type'
      if oprot.writeFieldBegin('system_mem_usage', TType.STRUCT, 13, annotations) < 0: return -1
      if self.system_mem_usage.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.system_cpu_usage is not None:
      annotations = {}
      annotations['tags'] = '.node_type,.cpu_share'
      if oprot.writeFieldBegin('system_cpu_usage', TType.STRUCT, 14, annotations) < 0: return -1
      if self.system_cpu_usage.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.running_package_version is not None:
      annotations = {}
      if oprot.writeFieldBegin('running_package_version', TType.STRING, 15, annotations) < 0: return -1
      if oprot.writeString(self.running_package_version) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.installed_package_version is not None:
      annotations = {}
      if oprot.writeFieldBegin('installed_package_version', TType.STRING, 16, annotations) < 0: return -1
      if oprot.writeString(self.installed_package_version) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.name is not None:
      log_str.write('name = ')
      log_str.write(self.name)
      log_str.write('  ')
    if self.deleted is not None:
      log_str.write('deleted = ')
      if self.deleted:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.status is not None:
      log_str.write('status = ')
      log_str.write(self.status)
      log_str.write('  ')
    if self.process_status is not None:
      log_str.write('process_status = ')
      log_str.write('[ ')
      for iter39 in self.process_status:
        log_str.write('<<  ')
        log_str.write(iter39.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.process_info is not None:
      log_str.write('process_info = ')
      log_str.write('[ ')
      for iter40 in self.process_info:
        log_str.write('<<  ')
        log_str.write(iter40.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.disk_usage_info is not None:
      log_str.write('disk_usage_info = ')
      log_str.write('{ ')
      for kiter41,viter42 in self.disk_usage_info.iteritems():
        log_str.write(kiter41)
        log_str.write(' : ')
        log_str.write('<<  ')
        log_str.write(viter42.log())
        log_str.write('>>')
      log_str.write(' }')
      log_str.write('  ')
    if self.description is not None:
      log_str.write('description = ')
      log_str.write(self.description)
      log_str.write('  ')
    if self.all_core_file_list is not None:
      log_str.write('all_core_file_list = ')
      log_str.write('[ ')
      for iter43 in self.all_core_file_list:
        log_str.write(iter43)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.build_info is not None:
      log_str.write('build_info = ')
      log_str.write(self.build_info)
      log_str.write('  ')
    if self.process_mem_cpu_usage is not None:
      log_str.write('process_mem_cpu_usage = ')
      log_str.write('{ ')
      for kiter44,viter45 in self.process_mem_cpu_usage.iteritems():
        log_str.write(kiter44)
        log_str.write(' : ')
        log_str.write('<<  ')
        log_str.write(viter45.log())
        log_str.write('>>')
      log_str.write(' }')
      log_str.write('  ')
    if self.system_cpu_info is not None:
      log_str.write('system_cpu_info = ')
      log_str.write('<<  ')
      log_str.write(self.system_cpu_info.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.system_mem_usage is not None:
      log_str.write('system_mem_usage = ')
      log_str.write('<<  ')
      log_str.write(self.system_mem_usage.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.system_cpu_usage is not None:
      log_str.write('system_cpu_usage = ')
      log_str.write('<<  ')
      log_str.write(self.system_cpu_usage.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.running_package_version is not None:
      log_str.write('running_package_version = ')
      log_str.write(self.running_package_version)
      log_str.write('  ')
    if self.installed_package_version is not None:
      log_str.write('installed_package_version = ')
      log_str.write(self.installed_package_version)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.name is not None:
      size += getsizeof(self.name)
    if self.deleted is not None:
      size += getsizeof(self.deleted)
    if self.status is not None:
      size += getsizeof(self.status)
    if self.process_status is not None:
      size += getsizeof(self.process_status)
      size += sum(map(getsizeof, self.process_status))
    if self.process_info is not None:
      size += getsizeof(self.process_info)
      size += sum(map(getsizeof, self.process_info))
    if self.disk_usage_info is not None:
      size += getsizeof(self.disk_usage_info)
      size += sum(map(getsizeof, chain.from_iterable(self.disk_usage_info.iteritems())))
    if self.description is not None:
      size += getsizeof(self.description)
    if self.all_core_file_list is not None:
      size += getsizeof(self.all_core_file_list)
      size += sum(map(getsizeof, self.all_core_file_list))
    if self.build_info is not None:
      size += getsizeof(self.build_info)
    if self.process_mem_cpu_usage is not None:
      size += getsizeof(self.process_mem_cpu_usage)
      size += sum(map(getsizeof, chain.from_iterable(self.process_mem_cpu_usage.iteritems())))
    if self.system_cpu_info is not None:
      size += getsizeof(self.system_cpu_info)
    if self.system_mem_usage is not None:
      size += getsizeof(self.system_mem_usage)
    if self.system_cpu_usage is not None:
      size += getsizeof(self.system_cpu_usage)
    if self.running_package_version is not None:
      size += getsizeof(self.running_package_version)
    if self.installed_package_version is not None:
      size += getsizeof(self.installed_package_version)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NodeStatusUVE(sandesh_base.SandeshUVE):

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data', (NodeStatus, NodeStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, data=None, table=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshUVE.__init__(self)
    self.data = data
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2524127670
    self._hints = 0 | SANDESH_KEY_HINT
    if table is not None:
      self.data._table = table

  def update_uve(self, tdata):
    if self.data.name is not None:
      tdata.name = self.data.name
    if self.data.deleted is not None:
      tdata.deleted = self.data.deleted
    if self.data.status is not None:
      tdata.status = self.data.status
    if self.data.process_status is not None:
      tdata.process_status = self.data.process_status
    if self.data.process_info is not None:
      tdata.process_info = self.data.process_info
    if self.data.disk_usage_info is not None:
      tdata.disk_usage_info = self.data.disk_usage_info
    if self.data.description is not None:
      tdata.description = self.data.description
    if self.data.all_core_file_list is not None:
      tdata.all_core_file_list = self.data.all_core_file_list
    if self.data.build_info is not None:
      tdata.build_info = self.data.build_info
    if self.data.process_mem_cpu_usage is not None:
      tdata.process_mem_cpu_usage = self.data.process_mem_cpu_usage
    if self.data.system_cpu_info is not None:
      tdata.system_cpu_info = self.data.system_cpu_info
    if self.data.system_mem_usage is not None:
      tdata.system_mem_usage = self.data.system_mem_usage
    if self.data.system_cpu_usage is not None:
      tdata.system_cpu_usage = self.data.system_cpu_usage
    if self.data.running_package_version is not None:
      tdata.running_package_version = self.data.running_package_version
    if self.data.installed_package_version is not None:
      tdata.installed_package_version = self.data.installed_package_version
    return tdata

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.data is not None:
      log_str.write('data = ')
      log_str.write('<<  ')
      log_str.write(self.data.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data = NodeStatus()
          read_cnt += self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.data is not None:
      annotations = {}
      if oprot.writeFieldBegin('data', TType.STRUCT, 1, annotations) < 0: return -1
      if self.data.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.data != other.data:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.data is not None:
      size += getsizeof(self.data)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
]


_SANDESH_UVE_LIST = [
(NodeStatusUVE, NodeStatus),
]


_SANDESH_ALARM_LIST = [
]
