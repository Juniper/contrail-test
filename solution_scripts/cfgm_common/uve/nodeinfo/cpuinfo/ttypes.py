#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class CpuLoadAvg(object):
  """
  Attributes:
   - one_min_avg
   - five_min_avg
   - fifteen_min_avg
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'one_min_avg', None, None, ), # 1
    (2, TType.DOUBLE, 'five_min_avg', None, None, ), # 2
    (3, TType.DOUBLE, 'fifteen_min_avg', None, None, ), # 3
  )

  def __init__(self, one_min_avg=None, five_min_avg=None, fifteen_min_avg=None,):
    self.one_min_avg = one_min_avg
    self.five_min_avg = five_min_avg
    self.fifteen_min_avg = fifteen_min_avg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          (length, self.one_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          (length, self.five_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          (length, self.fifteen_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.one_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('one_min_avg', TType.DOUBLE, 1, annotations) < 0: return -1
      if oprot.writeDouble(self.one_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.five_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('five_min_avg', TType.DOUBLE, 2, annotations) < 0: return -1
      if oprot.writeDouble(self.five_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.fifteen_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('fifteen_min_avg', TType.DOUBLE, 3, annotations) < 0: return -1
      if oprot.writeDouble(self.fifteen_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.one_min_avg is not None:
      log_str.write('one_min_avg = ')
      log_str.write(str(self.one_min_avg))
      log_str.write('  ')
    if self.five_min_avg is not None:
      log_str.write('five_min_avg = ')
      log_str.write(str(self.five_min_avg))
      log_str.write('  ')
    if self.fifteen_min_avg is not None:
      log_str.write('fifteen_min_avg = ')
      log_str.write(str(self.fifteen_min_avg))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.one_min_avg is not None:
      size += getsizeof(self.one_min_avg)
    if self.five_min_avg is not None:
      size += getsizeof(self.five_min_avg)
    if self.fifteen_min_avg is not None:
      size += getsizeof(self.fifteen_min_avg)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MemInfo(object):
  """
  Attributes:
   - virt
   - peakvirt
   - res
  """

  thrift_spec = (
    None, # 0
    (1, TType.U32, 'virt', None, None, ), # 1
    (2, TType.U32, 'peakvirt', None, None, ), # 2
    (3, TType.U32, 'res', None, None, ), # 3
  )

  def __init__(self, virt=None, peakvirt=None, res=None,):
    self.virt = virt
    self.peakvirt = peakvirt
    self.res = res

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.virt) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.peakvirt) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.res) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.virt is not None:
      annotations = {}
      if oprot.writeFieldBegin('virt', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.virt) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.peakvirt is not None:
      annotations = {}
      if oprot.writeFieldBegin('peakvirt', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.peakvirt) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.res is not None:
      annotations = {}
      if oprot.writeFieldBegin('res', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.res) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.virt is not None:
      log_str.write('virt = ')
      log_str.write(str(self.virt))
      log_str.write('  ')
    if self.peakvirt is not None:
      log_str.write('peakvirt = ')
      log_str.write(str(self.peakvirt))
      log_str.write('  ')
    if self.res is not None:
      log_str.write('res = ')
      log_str.write(str(self.res))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.virt is not None:
      size += getsizeof(self.virt)
    if self.peakvirt is not None:
      size += getsizeof(self.peakvirt)
    if self.res is not None:
      size += getsizeof(self.res)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SysMemInfo(object):
  """
  Attributes:
   - total
   - used
   - free
   - buffers
   - cached
   - node_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.U32, 'total', None, None, ), # 1
    (2, TType.U32, 'used', None, None, ), # 2
    (3, TType.U32, 'free', None, None, ), # 3
    (4, TType.U32, 'buffers', None, None, ), # 4
    (5, TType.U32, 'cached', None, None, ), # 5
    (6, TType.STRING, 'node_type', None, None, ), # 6
  )

  def __init__(self, total=None, used=None, free=None, buffers=None, cached=None, node_type=None,):
    self.total = total
    self.used = used
    self.free = free
    self.buffers = buffers
    self.cached = cached
    self.node_type = node_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.total) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.used) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.free) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U32:
          (length, self.buffers) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U32:
          (length, self.cached) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.node_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.total is not None:
      annotations = {}
      if oprot.writeFieldBegin('total', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.total) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.used is not None:
      annotations = {}
      if oprot.writeFieldBegin('used', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.used) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.free is not None:
      annotations = {}
      if oprot.writeFieldBegin('free', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.free) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.buffers is not None:
      annotations = {}
      if oprot.writeFieldBegin('buffers', TType.U32, 4, annotations) < 0: return -1
      if oprot.writeU32(self.buffers) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cached is not None:
      annotations = {}
      if oprot.writeFieldBegin('cached', TType.U32, 5, annotations) < 0: return -1
      if oprot.writeU32(self.cached) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.node_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('node_type', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.node_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.total is not None:
      log_str.write('total = ')
      log_str.write(str(self.total))
      log_str.write('  ')
    if self.used is not None:
      log_str.write('used = ')
      log_str.write(str(self.used))
      log_str.write('  ')
    if self.free is not None:
      log_str.write('free = ')
      log_str.write(str(self.free))
      log_str.write('  ')
    if self.buffers is not None:
      log_str.write('buffers = ')
      log_str.write(str(self.buffers))
      log_str.write('  ')
    if self.cached is not None:
      log_str.write('cached = ')
      log_str.write(str(self.cached))
      log_str.write('  ')
    if self.node_type is not None:
      log_str.write('node_type = ')
      log_str.write(self.node_type)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.total is not None:
      size += getsizeof(self.total)
    if self.used is not None:
      size += getsizeof(self.used)
    if self.free is not None:
      size += getsizeof(self.free)
    if self.buffers is not None:
      size += getsizeof(self.buffers)
    if self.cached is not None:
      size += getsizeof(self.cached)
    if self.node_type is not None:
      size += getsizeof(self.node_type)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CpuLoadInfo(object):
  """
  This structure carries
  - process's information - in meminfo and cpu_share
  - system's information in sys_mem_info and cpuload

  Attributes:
   - num_cpu
   - sys_mem_info
   - meminfo
   - cpuload
   - cpu_share
  """

  thrift_spec = (
    None, # 0
    (1, TType.U32, 'num_cpu', None, None, ), # 1
    (2, TType.STRUCT, 'meminfo', (MemInfo, MemInfo.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'cpuload', (CpuLoadAvg, CpuLoadAvg.thrift_spec), None, ), # 3
    (4, TType.DOUBLE, 'cpu_share', None, None, ), # 4
    (5, TType.STRUCT, 'sys_mem_info', (SysMemInfo, SysMemInfo.thrift_spec), None, ), # 5
  )

  def __init__(self, num_cpu=None, sys_mem_info=None, meminfo=None, cpuload=None, cpu_share=None,):
    self.num_cpu = num_cpu
    self.sys_mem_info = sys_mem_info
    self.meminfo = meminfo
    self.cpuload = cpuload
    self.cpu_share = cpu_share

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.num_cpu) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.sys_mem_info = SysMemInfo()
          read_cnt += self.sys_mem_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.meminfo = MemInfo()
          read_cnt += self.meminfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cpuload = CpuLoadAvg()
          read_cnt += self.cpuload.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          (length, self.cpu_share) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.num_cpu is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_cpu', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.num_cpu) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.meminfo is not None:
      annotations = {}
      if oprot.writeFieldBegin('meminfo', TType.STRUCT, 2, annotations) < 0: return -1
      if self.meminfo.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cpuload is not None:
      annotations = {}
      if oprot.writeFieldBegin('cpuload', TType.STRUCT, 3, annotations) < 0: return -1
      if self.cpuload.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cpu_share is not None:
      annotations = {}
      if oprot.writeFieldBegin('cpu_share', TType.DOUBLE, 4, annotations) < 0: return -1
      if oprot.writeDouble(self.cpu_share) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sys_mem_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('sys_mem_info', TType.STRUCT, 5, annotations) < 0: return -1
      if self.sys_mem_info.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.num_cpu is not None:
      log_str.write('num_cpu = ')
      log_str.write(str(self.num_cpu))
      log_str.write('  ')
    if self.sys_mem_info is not None:
      log_str.write('sys_mem_info = ')
      log_str.write('<<  ')
      log_str.write(self.sys_mem_info.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.meminfo is not None:
      log_str.write('meminfo = ')
      log_str.write('<<  ')
      log_str.write(self.meminfo.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.cpuload is not None:
      log_str.write('cpuload = ')
      log_str.write('<<  ')
      log_str.write(self.cpuload.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.cpu_share is not None:
      log_str.write('cpu_share = ')
      log_str.write(str(self.cpu_share))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.num_cpu is not None:
      size += getsizeof(self.num_cpu)
    if self.sys_mem_info is not None:
      size += getsizeof(self.sys_mem_info)
    if self.meminfo is not None:
      size += getsizeof(self.meminfo)
    if self.cpuload is not None:
      size += getsizeof(self.cpuload)
    if self.cpu_share is not None:
      size += getsizeof(self.cpu_share)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProcessCpuInfo(object):
  """
  This structure carries process's memory and cpu information,
  this is used to store cpu and memory statistics on a per process basis

  Attributes:
   - module_id
   - inst_id
   - mem_virt
   - cpu_share
   - mem_res
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'module_id', None, None, ), # 1
    (2, TType.STRING, 'inst_id', None, None, ), # 2
    (3, TType.U32, 'mem_virt', None, None, ), # 3
    (4, TType.DOUBLE, 'cpu_share', None, None, ), # 4
    (5, TType.U32, 'mem_res', None, None, ), # 5
  )

  def __init__(self, module_id=None, inst_id=None, mem_virt=None, cpu_share=None, mem_res=None,):
    self.module_id = module_id
    self.inst_id = inst_id
    self.mem_virt = mem_virt
    self.cpu_share = cpu_share
    self.mem_res = mem_res

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.module_id) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.inst_id) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.mem_virt) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          (length, self.cpu_share) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U32:
          (length, self.mem_res) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.module_id is not None:
      annotations = {}
      if oprot.writeFieldBegin('module_id', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.module_id) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.inst_id is not None:
      annotations = {}
      if oprot.writeFieldBegin('inst_id', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.inst_id) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.mem_virt is not None:
      annotations = {}
      if oprot.writeFieldBegin('mem_virt', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.mem_virt) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cpu_share is not None:
      annotations = {}
      if oprot.writeFieldBegin('cpu_share', TType.DOUBLE, 4, annotations) < 0: return -1
      if oprot.writeDouble(self.cpu_share) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.mem_res is not None:
      annotations = {}
      if oprot.writeFieldBegin('mem_res', TType.U32, 5, annotations) < 0: return -1
      if oprot.writeU32(self.mem_res) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.module_id is not None:
      log_str.write('module_id = ')
      log_str.write(self.module_id)
      log_str.write('  ')
    if self.inst_id is not None:
      log_str.write('inst_id = ')
      log_str.write(self.inst_id)
      log_str.write('  ')
    if self.mem_virt is not None:
      log_str.write('mem_virt = ')
      log_str.write(str(self.mem_virt))
      log_str.write('  ')
    if self.cpu_share is not None:
      log_str.write('cpu_share = ')
      log_str.write(str(self.cpu_share))
      log_str.write('  ')
    if self.mem_res is not None:
      log_str.write('mem_res = ')
      log_str.write(str(self.mem_res))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.module_id is not None:
      size += getsizeof(self.module_id)
    if self.inst_id is not None:
      size += getsizeof(self.inst_id)
    if self.mem_virt is not None:
      size += getsizeof(self.mem_virt)
    if self.cpu_share is not None:
      size += getsizeof(self.cpu_share)
    if self.mem_res is not None:
      size += getsizeof(self.mem_res)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SystemCpuInfo(object):
  """
  Attributes:
   - num_socket
   - num_cpu
   - num_core_per_socket
   - num_thread_per_core
  """

  thrift_spec = (
    None, # 0
    (1, TType.U32, 'num_socket', None, None, ), # 1
    (2, TType.U32, 'num_cpu', None, None, ), # 2
    (3, TType.U32, 'num_core_per_socket', None, None, ), # 3
    (4, TType.U32, 'num_thread_per_core', None, None, ), # 4
  )

  def __init__(self, num_socket=None, num_cpu=None, num_core_per_socket=None, num_thread_per_core=None,):
    self.num_socket = num_socket
    self.num_cpu = num_cpu
    self.num_core_per_socket = num_core_per_socket
    self.num_thread_per_core = num_thread_per_core

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.num_socket) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.num_cpu) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.num_core_per_socket) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U32:
          (length, self.num_thread_per_core) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.num_socket is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_socket', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.num_socket) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_cpu is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_cpu', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.num_cpu) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_core_per_socket is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_core_per_socket', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.num_core_per_socket) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_thread_per_core is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_thread_per_core', TType.U32, 4, annotations) < 0: return -1
      if oprot.writeU32(self.num_thread_per_core) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.num_socket is not None:
      log_str.write('num_socket = ')
      log_str.write(str(self.num_socket))
      log_str.write('  ')
    if self.num_cpu is not None:
      log_str.write('num_cpu = ')
      log_str.write(str(self.num_cpu))
      log_str.write('  ')
    if self.num_core_per_socket is not None:
      log_str.write('num_core_per_socket = ')
      log_str.write(str(self.num_core_per_socket))
      log_str.write('  ')
    if self.num_thread_per_core is not None:
      log_str.write('num_thread_per_core = ')
      log_str.write(str(self.num_thread_per_core))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.num_socket is not None:
      size += getsizeof(self.num_socket)
    if self.num_cpu is not None:
      size += getsizeof(self.num_cpu)
    if self.num_core_per_socket is not None:
      size += getsizeof(self.num_core_per_socket)
    if self.num_thread_per_core is not None:
      size += getsizeof(self.num_thread_per_core)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SysCpuInfo(object):
  """
  This structure carries system's cpu information.

  Attributes:
   - one_min_avg
   - five_min_avg
   - fifteen_min_avg
   - cpu_share
   - node_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'one_min_avg', None, None, ), # 1
    (2, TType.DOUBLE, 'five_min_avg', None, None, ), # 2
    (3, TType.DOUBLE, 'fifteen_min_avg', None, None, ), # 3
    (4, TType.DOUBLE, 'cpu_share', None, None, ), # 4
    (5, TType.STRING, 'node_type', None, None, ), # 5
  )

  def __init__(self, one_min_avg=None, five_min_avg=None, fifteen_min_avg=None, cpu_share=None, node_type=None,):
    self.one_min_avg = one_min_avg
    self.five_min_avg = five_min_avg
    self.fifteen_min_avg = fifteen_min_avg
    self.cpu_share = cpu_share
    self.node_type = node_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          (length, self.one_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          (length, self.five_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          (length, self.fifteen_min_avg) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          (length, self.cpu_share) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.node_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.one_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('one_min_avg', TType.DOUBLE, 1, annotations) < 0: return -1
      if oprot.writeDouble(self.one_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.five_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('five_min_avg', TType.DOUBLE, 2, annotations) < 0: return -1
      if oprot.writeDouble(self.five_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.fifteen_min_avg is not None:
      annotations = {}
      if oprot.writeFieldBegin('fifteen_min_avg', TType.DOUBLE, 3, annotations) < 0: return -1
      if oprot.writeDouble(self.fifteen_min_avg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cpu_share is not None:
      annotations = {}
      if oprot.writeFieldBegin('cpu_share', TType.DOUBLE, 4, annotations) < 0: return -1
      if oprot.writeDouble(self.cpu_share) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.node_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('node_type', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.node_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.one_min_avg is not None:
      log_str.write('one_min_avg = ')
      log_str.write(str(self.one_min_avg))
      log_str.write('  ')
    if self.five_min_avg is not None:
      log_str.write('five_min_avg = ')
      log_str.write(str(self.five_min_avg))
      log_str.write('  ')
    if self.fifteen_min_avg is not None:
      log_str.write('fifteen_min_avg = ')
      log_str.write(str(self.fifteen_min_avg))
      log_str.write('  ')
    if self.cpu_share is not None:
      log_str.write('cpu_share = ')
      log_str.write(str(self.cpu_share))
      log_str.write('  ')
    if self.node_type is not None:
      log_str.write('node_type = ')
      log_str.write(self.node_type)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.one_min_avg is not None:
      size += getsizeof(self.one_min_avg)
    if self.five_min_avg is not None:
      size += getsizeof(self.five_min_avg)
    if self.fifteen_min_avg is not None:
      size += getsizeof(self.fifteen_min_avg)
    if self.cpu_share is not None:
      size += getsizeof(self.cpu_share)
    if self.node_type is not None:
      size += getsizeof(self.node_type)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CpuLoadInfoReq(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = CpuLoadInfoReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "CpuLoadInfoReq" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "CpuLoadInfoReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "CpuLoadInfoReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CpuLoadInfoResp(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.STRUCT, 'cpu_info', (CpuLoadInfo, CpuLoadInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, cpu_info=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.cpu_info = cpu_info
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2917728913
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.cpu_info is not None:
      log_str.write('cpu_info = ')
      log_str.write('<<  ')
      log_str.write(self.cpu_info.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cpu_info = CpuLoadInfo()
          read_cnt += self.cpu_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.cpu_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('cpu_info', TType.STRUCT, 1, annotations) < 0: return -1
      if self.cpu_info.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.cpu_info != other.cpu_info:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.cpu_info is not None:
      size += getsizeof(self.cpu_info)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
CpuLoadInfoReq,
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
