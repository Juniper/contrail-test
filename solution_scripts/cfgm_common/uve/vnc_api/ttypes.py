#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class VncApiCommon(object):
  """
  VNC API Module

  Attributes:
   - identifier_uuid: object uuid (dashed notation)
   - object_type: e.g. virtual_network
   - identifier_name: fq_name as string joined by ':'. e.g. domain-1:project-1:vn-1
   - url
   - operation: The type of operation. e.g. get/post/put/delete etc.
   - useragent: which program is doing operation e.g. a3s10:/usr/bin/contrail-schema
   - remote_ip: which host is doing operation e.g. 10.84.16.10:8082
   - params
   - body: data for operation
   - domain: index to find operations by domain
   - project: index to find operations by project
   - user: index to find operations by user
   - error: error message (if any) while attempting operation
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier_uuid', None, None, ), # 1
    (2, TType.STRING, 'object_type', None, None, ), # 2
    (3, TType.STRING, 'identifier_name', None, None, ), # 3
    (4, TType.STRING, 'url', None, None, ), # 4
    (5, TType.STRING, 'operation', None, None, ), # 5
    (6, TType.STRING, 'useragent', None, None, ), # 6
    (7, TType.STRING, 'remote_ip', None, None, ), # 7
    (8, TType.STRING, 'params', None, None, ), # 8
    (9, TType.STRING, 'body', None, None, ), # 9
    (10, TType.STRING, 'domain', None, None, ), # 10
    (11, TType.STRING, 'project', None, None, ), # 11
    (12, TType.STRING, 'user', None, None, ), # 12
    (13, TType.STRING, 'error', None, None, ), # 13
  )

  def __init__(self, identifier_uuid=None, object_type=None, identifier_name=None, url=None, operation=None, useragent=None, remote_ip=None, params=None, body=None, domain=None, project=None, user=None, error=None,):
    self.identifier_uuid = identifier_uuid
    self.object_type = object_type
    self.identifier_name = identifier_name
    self.url = url
    self.operation = operation
    self.useragent = useragent
    self.remote_ip = remote_ip
    self.params = params
    self.body = body
    self.domain = domain
    self.project = project
    self.user = user
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.identifier_uuid) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.object_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.identifier_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.url) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.operation) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.useragent) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          (length, self.remote_ip) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          (length, self.params) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          (length, self.body) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          (length, self.domain) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          (length, self.project) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          (length, self.user) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          (length, self.error) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.identifier_uuid is not None:
      annotations = {}
      if oprot.writeFieldBegin('identifier_uuid', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.identifier_uuid) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.object_type is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTable'
      if oprot.writeFieldBegin('object_type', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.object_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.identifier_name is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTable'
      if oprot.writeFieldBegin('identifier_name', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.identifier_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.url is not None:
      annotations = {}
      if oprot.writeFieldBegin('url', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.url) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.operation is not None:
      annotations = {}
      if oprot.writeFieldBegin('operation', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.operation) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.useragent is not None:
      annotations = {}
      if oprot.writeFieldBegin('useragent', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.useragent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.remote_ip is not None:
      annotations = {}
      if oprot.writeFieldBegin('remote_ip', TType.STRING, 7, annotations) < 0: return -1
      if oprot.writeString(self.remote_ip) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.params is not None:
      annotations = {}
      if oprot.writeFieldBegin('params', TType.STRING, 8, annotations) < 0: return -1
      if oprot.writeString(self.params) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.body is not None:
      annotations = {}
      if oprot.writeFieldBegin('body', TType.STRING, 9, annotations) < 0: return -1
      if oprot.writeString(self.body) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.domain is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTableByUser'
      if oprot.writeFieldBegin('domain', TType.STRING, 10, annotations) < 0: return -1
      if oprot.writeString(self.domain) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.project is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTableByUser'
      if oprot.writeFieldBegin('project', TType.STRING, 11, annotations) < 0: return -1
      if oprot.writeString(self.project) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.user is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTableByUser'
      if oprot.writeFieldBegin('user', TType.STRING, 12, annotations) < 0: return -1
      if oprot.writeString(self.user) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.error is not None:
      annotations = {}
      if oprot.writeFieldBegin('error', TType.STRING, 13, annotations) < 0: return -1
      if oprot.writeString(self.error) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.identifier_uuid is not None:
      log_str.write('identifier_uuid = ')
      log_str.write(self.identifier_uuid)
      log_str.write('  ')
    if self.object_type is not None:
      log_str.write('object_type = ')
      log_str.write(self.object_type)
      log_str.write('  ')
    if self.identifier_name is not None:
      log_str.write('identifier_name = ')
      log_str.write(self.identifier_name)
      log_str.write('  ')
    if self.url is not None:
      log_str.write('url = ')
      log_str.write(self.url)
      log_str.write('  ')
    if self.operation is not None:
      log_str.write('operation = ')
      log_str.write(self.operation)
      log_str.write('  ')
    if self.useragent is not None:
      log_str.write('useragent = ')
      log_str.write(self.useragent)
      log_str.write('  ')
    if self.remote_ip is not None:
      log_str.write('remote_ip = ')
      log_str.write(self.remote_ip)
      log_str.write('  ')
    if self.params is not None:
      log_str.write('params = ')
      log_str.write(self.params)
      log_str.write('  ')
    if self.body is not None:
      log_str.write('body = ')
      log_str.write(self.body)
      log_str.write('  ')
    if self.domain is not None:
      log_str.write('domain = ')
      log_str.write(self.domain)
      log_str.write('  ')
    if self.project is not None:
      log_str.write('project = ')
      log_str.write(self.project)
      log_str.write('  ')
    if self.user is not None:
      log_str.write('user = ')
      log_str.write(self.user)
      log_str.write('  ')
    if self.error is not None:
      log_str.write('error = ')
      log_str.write(self.error)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.identifier_uuid is not None:
      size += getsizeof(self.identifier_uuid)
    if self.object_type is not None:
      size += getsizeof(self.object_type)
    if self.identifier_name is not None:
      size += getsizeof(self.identifier_name)
    if self.url is not None:
      size += getsizeof(self.url)
    if self.operation is not None:
      size += getsizeof(self.operation)
    if self.useragent is not None:
      size += getsizeof(self.useragent)
    if self.remote_ip is not None:
      size += getsizeof(self.remote_ip)
    if self.params is not None:
      size += getsizeof(self.params)
    if self.body is not None:
      size += getsizeof(self.body)
    if self.domain is not None:
      size += getsizeof(self.domain)
    if self.project is not None:
      size += getsizeof(self.project)
    if self.user is not None:
      size += getsizeof(self.user)
    if self.error is not None:
      size += getsizeof(self.error)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ContrailConfig(object):
  """
  Attributes:
   - name: fq_name string with joined by ':'
   - elements: notification message details
   - deleted: was the operation a delete notification
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.MAP, 'elements', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.BOOL, 'deleted', None, None, ), # 3
  )

  def __init__(self, name=None, elements=None, deleted=None,):
    self.name = name
    self.elements = elements
    self.deleted = deleted
    self._table = 'none'

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.elements = {}
          (length, _ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i4 in xrange(_size0):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key5) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val6) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.elements[_key5] = _val6
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          (length, self.deleted) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.name is not None:
      annotations = {}
      if self._table is None or self._table is '': return -1
      annotations['key'] = self._table
      if oprot.writeFieldBegin('name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.elements is not None:
      annotations = {}
      if oprot.writeFieldBegin('elements', TType.MAP, 2, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.elements)) < 0: return -1
      for kiter7,viter8 in self.elements.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter7) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(viter8) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.deleted is not None:
      annotations = {}
      if oprot.writeFieldBegin('deleted', TType.BOOL, 3, annotations) < 0: return -1
      if oprot.writeBool(self.deleted) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.name is not None:
      log_str.write('name = ')
      log_str.write(self.name)
      log_str.write('  ')
    if self.elements is not None:
      log_str.write('elements = ')
      log_str.write('{ ')
      for kiter9,viter10 in self.elements.iteritems():
        log_str.write(kiter9)
        log_str.write(' : ')
        log_str.write(viter10)
      log_str.write(' }')
      log_str.write('  ')
    if self.deleted is not None:
      log_str.write('deleted = ')
      if self.deleted:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.name is not None:
      size += getsizeof(self.name)
    if self.elements is not None:
      size += getsizeof(self.elements)
      size += sum(map(getsizeof, chain.from_iterable(self.elements.iteritems())))
    if self.deleted is not None:
      size += getsizeof(self.deleted)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiStats(object):
  """
  Attributes:
   - operation_type: (GET, PUT, POST, DELETE)
   - user: user performing operation
   - useragent: which program is doing operation e.g. a3s10:/usr/bin/contrail-schema
   - remote_ip: which host is doing operation e.g. 10.84.16.10:8082
   - domain_name
   - project_name
   - object_type
   - response_time_in_usec: time for completing operation in microseconds
   - response_size: size of returned response in bytes
   - resp_code: http status code for response e.g. 200, 404 etc.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'operation_type', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'useragent', None, None, ), # 3
    (4, TType.STRING, 'remote_ip', None, None, ), # 4
    (5, TType.STRING, 'domain_name', None, None, ), # 5
    (6, TType.STRING, 'project_name', None, None, ), # 6
    (7, TType.STRING, 'object_type', None, None, ), # 7
    (8, TType.DOUBLE, 'response_time_in_usec', None, None, ), # 8
    (9, TType.U64, 'response_size', None, None, ), # 9
    (10, TType.STRING, 'resp_code', None, None, ), # 10
  )

  def __init__(self, operation_type=None, user=None, useragent=None, remote_ip=None, domain_name=None, project_name=None, object_type=None, response_time_in_usec=None, response_size=None, resp_code=None,):
    self.operation_type = operation_type
    self.user = user
    self.useragent = useragent
    self.remote_ip = remote_ip
    self.domain_name = domain_name
    self.project_name = project_name
    self.object_type = object_type
    self.response_time_in_usec = response_time_in_usec
    self.response_size = response_size
    self.resp_code = resp_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.operation_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.user) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.useragent) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.remote_ip) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.domain_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.project_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          (length, self.object_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          (length, self.response_time_in_usec) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.U64:
          (length, self.response_size) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          (length, self.resp_code) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.operation_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('operation_type', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.operation_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.user is not None:
      annotations = {}
      if oprot.writeFieldBegin('user', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.user) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.useragent is not None:
      annotations = {}
      if oprot.writeFieldBegin('useragent', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.useragent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.remote_ip is not None:
      annotations = {}
      if oprot.writeFieldBegin('remote_ip', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.remote_ip) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.domain_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('domain_name', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.domain_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.project_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('project_name', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.project_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.object_type is not None:
      annotations = {}
      annotations['key'] = 'ConfigObjectTable'
      if oprot.writeFieldBegin('object_type', TType.STRING, 7, annotations) < 0: return -1
      if oprot.writeString(self.object_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.response_time_in_usec is not None:
      annotations = {}
      if oprot.writeFieldBegin('response_time_in_usec', TType.DOUBLE, 8, annotations) < 0: return -1
      if oprot.writeDouble(self.response_time_in_usec) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.response_size is not None:
      annotations = {}
      if oprot.writeFieldBegin('response_size', TType.U64, 9, annotations) < 0: return -1
      if oprot.writeU64(self.response_size) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.resp_code is not None:
      annotations = {}
      if oprot.writeFieldBegin('resp_code', TType.STRING, 10, annotations) < 0: return -1
      if oprot.writeString(self.resp_code) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.operation_type is not None:
      log_str.write('operation_type = ')
      log_str.write(self.operation_type)
      log_str.write('  ')
    if self.user is not None:
      log_str.write('user = ')
      log_str.write(self.user)
      log_str.write('  ')
    if self.useragent is not None:
      log_str.write('useragent = ')
      log_str.write(self.useragent)
      log_str.write('  ')
    if self.remote_ip is not None:
      log_str.write('remote_ip = ')
      log_str.write(self.remote_ip)
      log_str.write('  ')
    if self.domain_name is not None:
      log_str.write('domain_name = ')
      log_str.write(self.domain_name)
      log_str.write('  ')
    if self.project_name is not None:
      log_str.write('project_name = ')
      log_str.write(self.project_name)
      log_str.write('  ')
    if self.object_type is not None:
      log_str.write('object_type = ')
      log_str.write(self.object_type)
      log_str.write('  ')
    if self.response_time_in_usec is not None:
      log_str.write('response_time_in_usec = ')
      log_str.write(str(self.response_time_in_usec))
      log_str.write('  ')
    if self.response_size is not None:
      log_str.write('response_size = ')
      log_str.write(str(self.response_size))
      log_str.write('  ')
    if self.resp_code is not None:
      log_str.write('resp_code = ')
      log_str.write(self.resp_code)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.operation_type is not None:
      size += getsizeof(self.operation_type)
    if self.user is not None:
      size += getsizeof(self.user)
    if self.useragent is not None:
      size += getsizeof(self.useragent)
    if self.remote_ip is not None:
      size += getsizeof(self.remote_ip)
    if self.domain_name is not None:
      size += getsizeof(self.domain_name)
    if self.project_name is not None:
      size += getsizeof(self.project_name)
    if self.object_type is not None:
      size += getsizeof(self.object_type)
    if self.response_time_in_usec is not None:
      size += getsizeof(self.response_time_in_usec)
    if self.response_size is not None:
      size += getsizeof(self.response_size)
    if self.resp_code is not None:
      size += getsizeof(self.resp_code)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiReadLog(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, api_log=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE_OBJECT)
    self.api_log = api_log
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 103727244
    self._hints = 0 | SANDESH_KEY_HINT

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_log is not None:
      log_str.write('api_log = ')
      log_str.write('<<  ')
      log_str.write(self.api_log.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.file is not None:
      log_str.write('file = ')
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write('line = ')
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.api_log = VncApiCommon()
          read_cnt += self.api_log.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_log is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_log', TType.STRUCT, 1, annotations) < 0: return -1
      if self.api_log.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_log != other.api_log:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_log is not None:
      size += getsizeof(self.api_log)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiConfigLog(sandesh_base.SandeshObject):

  thrift_spec = None

  def __init__(self, api_log=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshObject.__init__(self)
    self.api_log = api_log
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 103727244
    self._hints = 0 | SANDESH_KEY_HINT
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_log is not None:
      log_str.write('api_log = ')
      log_str.write('<<  ')
      log_str.write(self.api_log.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.file is not None:
      log_str.write('file = ')
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write('line = ')
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.api_log = VncApiCommon()
          read_cnt += self.api_log.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_log is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_log', TType.STRUCT, 1, annotations) < 0: return -1
      if self.api_log.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_log != other.api_log:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_log is not None:
      size += getsizeof(self.api_log)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiDebug(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, api_msg=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.api_msg = api_msg
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_msg is not None:
      log_str.write(self.api_msg)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.api_msg) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_msg', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.api_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_msg != other.api_msg:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_msg is not None:
      size += getsizeof(self.api_msg)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiInfo(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, api_msg=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.api_msg = api_msg
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_msg is not None:
      log_str.write(self.api_msg)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.api_msg) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_msg', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.api_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_msg != other.api_msg:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_msg is not None:
      size += getsizeof(self.api_msg)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiNotice(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, api_msg=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.api_msg = api_msg
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_msg is not None:
      log_str.write(self.api_msg)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.api_msg) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_msg', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.api_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_msg != other.api_msg:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_msg is not None:
      size += getsizeof(self.api_msg)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiError(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, api_msg=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.api_msg = api_msg
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_msg is not None:
      log_str.write(self.api_msg)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.api_msg) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('api_msg', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.api_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_msg != other.api_msg:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_msg is not None:
      size += getsizeof(self.api_msg)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ContrailConfigTrace(sandesh_base.SandeshDynamicUVE):

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data', (ContrailConfig, ContrailConfig.thrift_spec), None, ), # 1
  )

  def __init__(self, data=None, table=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshDynamicUVE.__init__(self)
    self.data = data
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1420128436
    self._hints = 0 | SANDESH_KEY_HINT
    if table is not None:
      self.data._table = table

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.data is not None:
      log_str.write('data = ')
      log_str.write('<<  ')
      log_str.write(self.data.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data = ContrailConfig()
          read_cnt += self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.data is not None:
      annotations = {}
      if oprot.writeFieldBegin('data', TType.STRUCT, 1, annotations) < 0: return -1
      if self.data.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.data != other.data:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.data is not None:
      size += getsizeof(self.data)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VncApiStatsLog(sandesh_base.SandeshObject):

  thrift_spec = None

  def __init__(self, api_stats=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshObject.__init__(self)
    self.api_stats = api_stats
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1424419673
    self._hints = 0 | SANDESH_KEY_HINT
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.api_stats is not None:
      log_str.write('api_stats = ')
      log_str.write('<<  ')
      log_str.write(self.api_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.file is not None:
      log_str.write('file = ')
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write('line = ')
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.api_stats = VncApiStats()
          read_cnt += self.api_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.api_stats is not None:
      annotations = {}
      annotations['tags'] = '.operation_type,.user,.useragent,.remote_ip,.domain_name:.project_name,.object_type,.response_time_in_usec,.response_size,.resp_code'
      if oprot.writeFieldBegin('api_stats', TType.STRUCT, 1, annotations) < 0: return -1
      if self.api_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.api_stats != other.api_stats:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.api_stats is not None:
      size += getsizeof(self.api_stats)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
]


_SANDESH_UVE_LIST = [
(ContrailConfigTrace, ContrailConfig),
]


_SANDESH_ALARM_LIST = [
]
